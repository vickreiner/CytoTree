---
title: "Flow analysis pipeline based on CytoTree for efficient integration of manual and cluster driven population analysis"
author: "Victor Kreiner"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Platypus Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
fig_width: 16
fig_height: 16
---

** Changelog V0 **
- Developmental version in testing

## Citation

This script was generated by **Victor Kreiner**. Relevant use of this script in any project should be credited accordingly.
For minor contributions consider including author(s) in acknowledgements
For major contributions consider including author(s) as a co-authors
Do not publish or share this script with anyone outside Becher-Greter-Tugues-Mundt-Labs without permission from the author(s)

#0. Introduction

The idea for this pipeline came from the incompatibility of manual gating with clustering-driven analysis. 
I believe that both have their merit and that the strengths of each can complement the other. 
Specifically I plan to use manual gating for easy and well-controlled definition of basic population. Clustering analysis can then highlight issues in manual gating and - most importantly - use all markers to achieve a much higher resolution of cell type definitions. 

Section 1
The first section of this pipeline is based on FlowJo and custom functions. Unfortunately it takes some trickery to efficiently export FlowJo manual gating information per cell
After the first section we will have an .fcs file for each manually gated population of each sample and a metadata file, which includes all neccessary and custom annotations

Section 2
In the second section we will use the CytoTree package (https://github.com/JhuangLab/CytoTree / https://doi.org/10.1186/s12859-021-04054-2) to build a Cytotree object. 
Normalization can be done via the CytoTree package or via an implementation of Can`s normalization Shiny app 

Section 3
In the third section we use CytoTree and FlowSOM to cluster our cells, calculate dimensional reductions and annotate celltypes. The idea is that we start with preexisting information from manual gating and validate and extend this in clustering
This will include visualizations of all sorts

Section 4 
In the fourth section we will employ my existing flowFeatures pipeline to test for significant differences within Counts / Frequencies / Marker expressions etc. between samples, groups and cell populations. 
We will further calculate PCAs on samples on selected metrics to summarise our findings

```{r, setup, include=FALSE, eval = TRUE}
#to avoid of the dplyr summarise warnings
library(dplyr, warn.conflicts = FALSE)
options(dplyr.summarise.inform = FALSE)
library(stats, warn.conflicts = F)
knitr::opts_chunk$set(fig.width=7, fig.height=7) 
library(flowCore)
library(cowplot)
library(pheatmap)
library(gmodels)
library(destiny)
library(limma)

#devtools::install_github("jspidlen/flowUtils")
#devtools::install_github("JhuangLab/CytoTree")
library(CytoTree)
library(Rtsne)
library(cluster)
library(umap)

#helper function to save pdfs (VK 05.2023)
spdf <- function(file, d = 7:7){ #first number is width, second is height
  pl <- ggplot2::last_plot()
  pdf(paste0(file,".pdf"), width = d[1], height = d[length(d)])
  print(pl)
  dev.off()
}

wd <- "/Volumes/G_Inflammation_research$/People/Kreiner/PROJECTS/pro005_PregnancyImmuneAlterationsScreen/20230320_VK011_SynAlloExp3_d3111/3_analysis/an005_CytoTreePipeline_UTERUS_v1"
setwd(wd)
```

#1.1 Functions definition 

```{r, fig.show='hold', eval = FALSE}
source("/Volumes/G_Inflammation_research$/People/Kreiner/SCRIPTS/GITHUB/CytoTree/R/CytoTreePipeline_VK_V1.R")
for(i in list.files("/Volumes/G_Inflammation_research$/People/Kreiner/SCRIPTS/GITHUB/CytoTree/R/", full.names = T)){
  print(i)
  source(i)
}
```

#1.2 Data concatenation in FLOWJO

Import test from manually gated populations

1. Select terminal (! All populations that do not have a black arrow on the right side of them / dont have any children) manually gated populations
2. Select these for all samples
3. Go to populations -> export or concatenate
4. select export
5. choose all compensated parameters or a custom set of parameters
6. click advanced options
7. File naming: 
  7.1 Below Prefix, set Body to "Custom" and then click edit
  7.2 ! Before changing anything, verifiy if the default setting are already correct - this is usually the case here
  7.3 Pattern must be set to: "$FIL_FJ_LAST_UNIQUE_POP_NAME" / Sepratator must be set to "_" / ! The example should read something like: export_YourFCSfilename_CD4Tcells.fcs
  7.4. Click OK
  7.5. ! DO NOT ADD A SUFFIX. Leave the Suffix box empty
7. Check that the number of files that will be generated is equal to the total number of selections you have made (e.g. 10 populations x 4 samples will generate 40 .fcs files)
8. Click export
10. Done -> lets move to R :) 

#1.3 Generate a metadata template for manual annotation

```{r, fig.show='hold', eval = FALSE}

#set directory where your exported .fcs file are located
#! Whitespaces or _ in filenames may cause the metadata template to fail
fcs.file.directory <- "/Volumes/G_Inflammation_research$/People/Kreiner/PROJECTS/pro005_PregnancyImmuneAlterationsScreen/20230320_VK011_SynAlloExp3_d3111/2_compData/Uterus_for_CytoTreePipeline"

#run to get template metadata table
#You can add as many columns to this table as you like, as long as each column name is unique and does not contain whitespaces or special characters
SaveTemplateMetadataTable(path.to.fcs = fcs.file.directory,
                           out.file = "template.metadata.table.xlsx")


#Please fill out this table with all info that you may require later
#! Ensure to not change the raw.fcs and loading.nr columns as these will be required to merge the metadata table back in. You can change the sample_id, population etc. columns
#save the modified xlsx under another name and load it back in
md <- openxlsx::read.xlsx("metadata.table.v2.xlsx")
```

#1.4 Data Import

```{r, fig.show='hold', eval = FALSE}

#load in
#Nota Bene: you may use t he integrated transformation methods provided by CytoTree. These only allow for a single cofactor for all markers. 
#In case you want to have more control over the normalization, please use the ApplyCanformation function after creating loading in the data
#here you can subsample in diverse ways. See the documentation of the CytoTree runExprsMerge function. 
#For subsampling I added a method ("mergeMethod = "perc") which allows to load only "subsample.perc" of each raw.fcs file. This way numeric relation between abundances of populations are maintained. E.g. subsample.perc = 0.5 would return 50% of all cells for each .fcs file loaded
fcs.data <- runExprsMerge(fcsFiles = md$path_fcs, comp = FALSE, transformMethod = "none", mergeMethod = "all", subsample.perc = 1, fixedNum = 10000000)


#Simplify column names -> this will later only show the marker name and not the Fluorescent channel
fcs.data <- FilterAdjustMarkerNames(fcs.data = fcs.data, 
                                    keep.non.fluorescent.channels = FALSE)


```

#2.1 Custom data transformation via shiny  
All credit to Can Ulutekin, Becher Lab UZH, 2023

```{r, fig.show='hold', eval = FALSE}

library(shiny)
library(shinydashboard)
library(shinybusy)
library(bsplus)
library(flowCore)
library(dplyr)
library(magrittr)
library(ggplot2)
library(stringr)

source("/Volumes/G_Inflammation_research$/GitHub/Lab-Scripts/R_analysis-flow_cytometry/FlowInteractiveTransformation_CU/V1/CustomFunctions/cytoTransformerApp.R")
source("/Volumes/G_Inflammation_research$/GitHub/Lab-Scripts/R_analysis-flow_cytometry/FlowInteractiveTransformation_CU/V1/CustomFunctions/fcsReaderApp.R")

#! Define sample ID column in helper frame from rownames 
fcs.data.for.transform <- as.data.frame(fcs.data)
fcs.data.for.transform$sample_id <- gsub("_\\d+$", "", rownames(fcs.data.for.transform))

shinyCytoTransformer(data = fcs.data.for.transform)
#save parameters
saveRDS(transformation_parameters, "Shiny_TransParam_v1.rds")

#load parameters if neccessary
transformation_parameters <- readRDS("Shiny_TransParam_v1.rds")

#Transform fcs.data with the custom parameters
fcs.data_t <- ApplyTransformation(fcs.data = fcs.data,
                               shiny.transformation_parameters = transformation_parameters)

#cleanup
fcs.data.for.transform <- NULL
gc()
```

#2.2 Creating the CYT object

```{r, fig.show='hold', eval = FALSE}

#exclude nonDC population
fcs.data_t <- fcs.data_t[!stringr::str_detect(rownames(fcs.data_t), "NonDC"),]
md <- subset(md, !stringr::str_detect(md$raw_fcs, "NonDC"))

md <- md[!md$raw_fcs %in% c("export_export_U11_CD45, LD subset_Ly6Chi", "export_export_U5_CD45, LD subset_Ly6Chi", "export_export_U6_CD45, LD subset_Ly6Chi", "export_export_U7_CD45, LD subset_Ly6Chi", "export_export_U8_CD45, LD subset_Ly6Chi"),]

#Expand the initial metadata to match the 1 cell per row format of the input matrix
md.expanded <- ExpandMetadata(md,
                           fcs.data = fcs.data_t)


#to make lineage marker definition easier -> just copy from console without the outer ""
print(paste0("Markers: '", paste0(colnames(fcs.data), collapse = "', '"), "'"))

#create extended CYT object and define lineage markers just like in FlowSOM
cyt <- createCYT(raw.data = fcs.data_t, meta.data = md.expanded, normalization.method = "none", verbose = T,
                 lineage.markers = c('GITR', 'TCRb', 'MHCII', 'CD45', 'CD4', 'Ly6G', 'gdTCR', 'CD19', 'CD8a', 'CD11b', 'XCR1', 'CD25', 'NK11', 'CD11c', 'Foxp3', 'Ly6C'))

#print summary
cyt

#View Metadata
View(cyt@meta.data)

#intermediate save point
saveRDS(cyt,"CYT_obj_chunk1-6_v1_WOnonDCs.rds")

```

#3.1 Clustering Round 1 

We aim to cluster in rounds to allow for flexibility. 
Each round includes: Clustering & tree building and basic cluster analysis for annotation and QC
For the first round, or if input data has changed, dimensional reductions are also calculated

```{r, fig.show='hold', eval = FALSE}

#This behaves similarly to a seurat object and is nicely compatible with pipes from Tidyverse
  #the markers.to.use parameter can be set to 
cyt <- cyt %>% runCluster(k = 30, 
                        cluster.method = "clara",
                        scale = TRUE, 
                        verbose = TRUE, 
                        markers.to.use = "lineage") %>% processingCluster()
                        #Set markers.to.use to either "lineage", "state" or "all"

#We can also show a PCA embedding of the clusters.
plotCluster(cyt, item.use = c("PC_1", "PC_2")) 
spdf("CYT_clustering_3-1_ClusterPCA", 5:4)

#We can further overlay manually gated populations and clusters using barplots.
#This function was originally written for Platypus and adapted here (see: https://doi.org/10.1101/2022.09.28.509709 )
CytoProportionsBarplot(cyt, source.group = "cluster.id", target.group = "population", stacked.plot = T) + scale_fill_manual(values = pals::glasbey(32)) + theme(axis.text.x= element_text(angle = 50, hjust = 1))
spdf("CYT_clustering_3-1_ProportionsBarplot_ClustervsPopulation_trans", 6:4)

```

#3.1.2 UMAP

So far we have used all cells for clustering. For most Flow datasets this will not be possible for dimensional reductions, as this would take to much time and memory
Therefore we add a downsampling column: dowsample (I know its spelled wrong... it was like this in the CytoTree and I cannot be bothered to change that in all functions)

```{r, fig.show='hold', eval = FALSE}

#Set subsampling column
#Note that the original number of cells in the CYT object as well as the clustering will stay the same! 
cyt <- SetSubsamplingColumn(cyt = cyt,  
                               subsample.by.md.column = "raw_fcs", # by what column to subsample 
                               subsample.perc = 0.05) #Subsampling factor 0.5 = half of cells

#check this new colum
table(cyt@meta.data$dowsample)

#Using lineage markers to calculate dimensional reductions and build a lineage tree
#For further arguments to the individual functions please check the documentation from Cytotree
cyt <- cyt %>% runFastPCA(verbose = TRUE, markers.to.use = "lineage", downsample = TRUE) %>% 
                          runDiffusionMap(verbose = TRUE, markers.to.use = "lineage", downsample = TRUE) %>% 
                            runUMAP(verbose = TRUE, markers.to.use = "lineage", downsample = TRUE) %>%
                             buildTree(verbose = TRUE, dim.type = "raw", markers.to.use = "lineage", downsample = TRUE)

#We can now plot this colored by manually gated populations and new clusters
plot2D(cyt, item.use = c("UMAP_1", "UMAP_2"), color.by = "population", downsample = TRUE) + scale_color_manual(values = pals::glasbey(32))
#use this brief function to save as a pdf (width:height in inc)
spdf("CYT_clustering_3-1_UMAP_byPopulation", 8:6)

plot2D(cyt, item.use = c("UMAP_1", "UMAP_2"), color.by = "cluster.id", downsample = TRUE) + scale_color_manual(values = pals::glasbey(32)) #add to ggplot as you wish
spdf("CYT_clustering_3-1_UMAP_byCluster", 5:4)

#We can also plot a 2d Tree colored by a specific marker or just cell size
plotTree(cyt)
spdf("CYT_clustering_3-1_TREE_byCellNr", 5:4)

```

#3.2 Clustering QC and annotation (Line by Line)

Here we generate some QC plots and run basic analysis to find cluster-specific markers. We further generate a template xlsx table for cluster annotation. 
To recluster run the chunks above again. For subclustering, see section #3.5

! This chunk includes all plots individually. The chunk below wraps everything into one function
```{r, fig.show='hold', eval = FALSE}

#Heatmaps
plotClusterHeatmap(cyt, cluster_rows = FALSE, 
                   cluster_cols = FALSE, 
                   markers.to.use = "all",
                   downsample = FALSE,
                   scale = "column", 
                   group.by = "raw_fcs", 
                   cell.size = 15,
                   pdf.name = "CYT_clustering_3-2_HEATMAP_byRawFcs", #set to "none" to avoid saving plot
                   wh = 10:5) #height : width

plotClusterHeatmap(cyt, cluster_rows = TRUE, 
                   cluster_cols = FALSE, 
                   markers.to.use = "all", 
                   downsample = FALSE,
                   scale = "column", 
                   group.by = "cluster.id", 
                   cell.size = 15,
                   pdf.name = "CYT_clustering_3-2_HEATMAP_byCluster", #set to "none" to avoid saving plot
                   wh = 10:10) #height : width

plotClusterHeatmap(cyt, cluster_rows = FALSE, 
                   cluster_cols = FALSE, 
                   markers.to.use = "all",
                   downsample = FALSE,
                   scale = "column", 
                   group.by = "population", 
                   cell.size = 15,
                   pdf.name = "CYT_clustering_3-2_HEATMAP_byPopulation", #set to "none" to avoid saving plot
                   wh = 10:5) #height : width

#VLN plots 
pdf("CYT_clustering_3-2_VLN_allMarkers_byCluster.pdf", width = 7, height = 4)
for(i in cyt@markers){
  print(plotViolin(cyt, color.by = "cluster.id", marker = i, text.angle = 60, downsample = FALSE) + labs(title = i) + theme(legend.position = "none"))
}
dev.off()

#FeaturePlots
pdf("CYT_clustering_3-2_FeatureUMAP_allMarkers.pdf", width = 7, height = 5)
for(i in cyt@markers){
  print(plot2D(cyt, item.use = c("UMAP_1", "UMAP_2"), category = "numeric",
        size = 1, color.by = i, downsample = TRUE) + labs(title = i) + scale_color_viridis_c(option = "A"))
}
dev.off()

#Cluster-specific markers (1 cluster vs. all)
cl_markers <- runDiffFlex(cyt, grouping.column = "population", p.adjust.method = "BH")
cl_markers
openxlsx::write.xlsx(cl_markers,"CYT_clustering_3-2_ClusterMarkers.xlsx")

#Pairwise markers (each cluster vs. each other)
cl_markers <- runDiffFlex(cyt, grouping.column = "population", p.adjust.method = "BH", pairwise = TRUE)
cl_markers
openxlsx::write.xlsx(cl_markers,"CYT_clustering_3-2_ClusterMarkersPairwise.xlsx")

```

#3.3 Clustering QC and annotation (All IN ONE)

```{r, fig.show='hold', eval = FALSE}
#Run all cluster analysis in one wrapper -> check output files in working directory
AnalyzeClustersWrapper(cyt = cyt, file.prefix = "CYT_clustering_3-3", wh = 10:10,cell.size = 15)
```

#3.5 Subclustering

Subclustering one cluster will "backup" the previous clustering in the cluster.id.backup column and update the global cluster.id column. 
All other meta.data columns will be kept

```{r, fig.show='hold', eval = FALSE}

cyt <- SubclusterCyt(cyt = cyt,
                     cluster.to.subcluster = 1,
                     cluster.method = "clara", #Further Arguments passed to runCluster()
                     markers.to.use = "lineage", k = 6) 

plot2D(cyt, item.use = c("UMAP_1", "UMAP_2"), color.by = "cluster.id") #add to ggplot as you wish
spdf("CYT_REclustering_3-5_UMAP_byCluster", 5:4)

AnalyzeClustersWrapper(cyt = cyt, file.prefix = "CYT_reclustering_3-5", wh = 10:10,cell.size = 15)
```


#3.4 Celltype/Cluster annotation

```{r, fig.show='hold', eval = FALSE}
#Generate a template to add celltype annotations. Primary celltypes are meant as general terms, secondary as more detailed annotation
#If two clusters are labelled as the same celltype the code after will consider these "merged" 
SaveTemplateAnnotationTable(cyt = cyt,
                           out.file = "template.celltypeAnnotation.table.xlsx")

#Add annotations to CYT object
cyt <- AnnotateClusters(cyt, AnnotationTable.file = "celltypeAnnotation.table.xlsx")

#Plot celltypes
plot2D(cyt, item.use = c("UMAP_1", "UMAP_2"), color.by = "primary.celltype") + scale_color_manual(values = pals::glasbey(32)) #add to ggplot as you wish
spdf("CYT_clustering_3-1_UMAP_byPrimCelltype", 5:4)

plot2D(cyt, item.use = c("UMAP_1", "UMAP_2"), color.by = "secondary.celltype") + scale_color_manual(values = pals::glasbey(32)) #add to ggplot as you wish
spdf("CYT_clustering_3-1_UMAP_bySecCelltype", 5:4)
```

Savepoint
```{r, fig.show='hold', eval = FALSE}
saveRDS(cyt,"CYT_obj_chunk3-4_annotated_v1.rds")
```

#4.1 Preparation for FlowFeatures analysis

The idea of this analysis is to compare marker levels and frequencies (be aware of subsampling steps above) across conditions. 
Here this is done in three steps:
1. Generate tidy table (flowtidy) which is compatible with my manual gating FlowFeatures pipeline (see here: /Volumes/G_Inflammation_research$/GitHub/Lab-Scripts/R_analysis-flow_cytometry/FlowFeaturesManualGating_VK/V2)
2. Run the FlowFeatures analysis 
3. Export results as xlsx and generate plots

Generating a flowtidy dataframe 
! You may provide any column of the metadata to any of the grouping colums to allow maximum flexibility
```{r, fig.show='hold', eval = FALSE}

cyt@meta.data$sample_for_cyto <- stringr::str_extract(cyt@meta.data$raw_fcs, "U\\d+")
table(cyt@meta.data$sample_for_cyto)

library(tidyverse)

flowtidy <- GenerateFlowtidyDF(cyt = cyt, 
                               cyt.slot = "raw.data", #can be "log.data" or "raw.data"
                               sample.id.column = "sample_for_cyto", 
                               grouping.column = "group_id", #analysis across these
                               iteration.column = "primary.celltype") #iterating over these 

#save
openxlsx::write.xlsx(flowtidy, "CYT_4-1_flowtidyForTesting_v1.xlsx")
```

#4.2 Running all v all statistical testing 

```{r}
#run for each organ individually 
  res <- FlowTestGroups(flowtidy = flowtidy,
                           groups.column = "group", #x axis of resulting plots
                           populations.column = "population", #plot list grouped by this
                           samples.column = "sample",
                           population.levels.column = "level",
                           metrics.columns = "metric",
                           values.column = "value",
                           metrics = "all", # "all" or an array of entries from metrics.column
                           population.levels = "all", #"all" or one or more of entries in population.levels.column
                           populations = "all", #"all" or one or more of entries in populations.column
                           paired.samples = FALSE, #passed to pairwise.wilcox.test etc. 
                           p.adjust.method = "BH", #passed to pairwise.wilcox.test etc.. Can be: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"
                           signif.level = 0.05, #used to determine significance on corrected and uncorrected (aov) p values
                           NA.remove = TRUE, #TRUE to remove NAs, FALSE to replace NAs with 0
                           run.id = "CYT_4-2")
openxlsx::write.xlsx(res[[2]], file = paste0("CYT_4-1_TestGroupsRawResults.xlsx"))

```

#4.3 Boxplots for report

Plots are saved as one PDF in working directory
```{r}
bp <- FlowTestBoxplots(FlowTestGroups.table = res[[2]], #the full, or a subset, of the FlowTestGroups results list [[2]]
                             flowtidy = flowtidy, # the input dataframe to the FlowTestGroups call
                             plot.raw.pvalue = FALSE, #Default: FALSE, set to true to label with raw p.value
                             signif.level = 0.1,#p vals above this are not labelled
                             pdf.name = paste0("CYT_4-1_TestGroupsRawResults.pdf"), #name of output PDF. if set to "none", no pdf is generated
                             plot.save.width = 5.2,
                             plot.save.height = 3,
                             signif.anno.height.factor = 1,#change to increase or decrease height of signif annotation
                             signif.anno.cex = 3,
                             axis.label.cex = 7,
                             subtitle.size = 5,
                             boxplot.width = 0.6,
                             label.significant.with.symbols = TRUE, colors = pals::stepped2(20))
```

# SessionInfo
```{r}
utils::sessionInfo()
```

#Summary

This was a basic script for clustering Flow data with the help of manually gated populations. 
This is all based on the CytoTree package, Can`s transformation shiny app and my own work for manual gating analysis
In case of question come by or write me at kreiner@immunology.uzh.ch
I encourage anyone to contribute to improve and add functionalities! 

Current End of script. More features will be added in the future. 

VK 08.23

#### TESTING AREA ####

```{r}

```



